{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "e68d496a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Defaulting to user installation because normal site-packages is not writeable\n",
      "Requirement already satisfied: mysql-connector-python in c:\\users\\user\\appdata\\roaming\\python\\python312\\site-packages (8.4.0)\n",
      "Note: you may need to restart the kernel to use updated packages.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n",
      "[notice] A new release of pip is available: 24.0 -> 24.1\n",
      "[notice] To update, run: python.exe -m pip install --upgrade pip\n"
     ]
    }
   ],
   "source": [
    "pip install mysql-connector-python\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f3583e6a-8630-467a-9c75-ff76ba530a10",
   "metadata": {},
   "source": [
    "### 1. Imports 및 클래스 정의"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "4b5f5e33-f586-4c5a-aaa4-6162b03f54d9",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import os\n",
    "import concurrent.futures\n",
    "from tqdm import tqdm\n",
    "# from sqlalchemy import create_engine\n",
    "import pymysql\n",
    "import datetime\n",
    "import random\n",
    "import configparser\n",
    "from cryptography.fernet import Fernet\n",
    "import mysql.connector\n",
    "\n",
    "\n",
    "\n",
    "class Position:\n",
    "    def __init__(self, buy_price, quantity,order,additional_buy_drop_rate,sell_profit_rate):\n",
    "        self.buy_price = buy_price\n",
    "        self.quantity = quantity\n",
    "        self.order = order  # 포지션의 차수\n",
    "        self.additional_buy_drop_rate = additional_buy_drop_rate  # 추가 매수 드랍 비율 추가\n",
    "        self.sell_profit_rate = sell_profit_rate  # 매도 수익률 추가\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a8cbbe20-80c1-4df4-8f48-14fce33a7af9",
   "metadata": {},
   "source": [
    "### 2. 롤링 윈도우 계산 함수"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 106,
   "id": "917cc272-739e-4ec0-a4d8-142c2c79e941",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# 데이터베이스에서 조건을 만족하는 종목을 동적으로 가져오는 함수\n",
    "def get_stock_codes(date, per_threshold, pbr_threshold, div_threshold, normalized_value_threshold, db_params):\n",
    "    # 데이터베이스 연결\n",
    "    conn = mysql.connector.connect(**db_params)\n",
    "    cursor = conn.cursor()\n",
    "    # 날짜 형식 변환\n",
    "    date_str = pd.to_datetime(date).strftime('%Y-%m-%d')\n",
    "    print(f\"Converted date: {date_str}\")\n",
    "    # SQL 쿼리 실행\n",
    "    query = f\"\"\"\n",
    "    SELECT ticker \n",
    "    FROM stock_data \n",
    "    WHERE date = '{date_str}' \n",
    "    AND PER > 0 \n",
    "    AND PER <= {per_threshold} \n",
    "    AND PBR > 0 \n",
    "    AND PBR <= {pbr_threshold} \n",
    "    AND dividend >= {div_threshold}\n",
    "    AND normalized_value <= {normalized_value_threshold}\n",
    "    \"\"\"\n",
    "    cursor.execute(query)\n",
    "    # 결과를 DataFrame으로 변환\n",
    "    rows = cursor.fetchall()\n",
    "    df = pd.DataFrame(rows, columns=['ticker'])\n",
    "    \n",
    "    # 연결 종료\n",
    "    cursor.close()\n",
    "    conn.close()\n",
    "\n",
    "    # 'ticker' 컬럼의 값을 리스트로 반환\n",
    "    return df['ticker'].tolist()\n",
    "\n",
    "# MySQL에서 데이터를 불러오는 함수\n",
    "def load_stock_data_from_mysql(ticker, start_date, end_date, db_params):\n",
    "    conn = mysql.connector.connect(**db_params)\n",
    "    cursor = conn.cursor()\n",
    "    \n",
    "    start_date_str = pd.to_datetime(start_date).strftime('%Y-%m-%d')\n",
    "    end_date_str = pd.to_datetime(end_date).strftime('%Y-%m-%d')\n",
    "    \n",
    "    query = f\"\"\"\n",
    "        SELECT * FROM stock_data \n",
    "        WHERE ticker = '{ticker}' AND date BETWEEN '{start_date_str}' AND '{end_date_str}'\n",
    "    \"\"\"\n",
    "    cursor.execute(query)\n",
    "    \n",
    "    rows = cursor.fetchall()\n",
    "    columns = [desc[0] for desc in cursor.description]\n",
    "    df = pd.DataFrame(rows, columns=columns)\n",
    "    \n",
    "    # 날짜 형식 변환 및 인덱스 설정\n",
    "    df['date'] = pd.to_datetime(df['date'])\n",
    "    df.set_index('date', inplace=True)\n",
    "    \n",
    "    cursor.close()\n",
    "    conn.close()\n",
    "    \n",
    "    return df\n",
    "def load_all_stock_data(stock_codes, start_date, end_date, db_params):\n",
    "    stock_data = {}\n",
    "    for code in stock_codes:\n",
    "        df = load_stock_data_from_mysql(code, start_date, end_date, db_params)\n",
    "        df = rolling_window_calculations(df)\n",
    "        stock_data[code] = df\n",
    "        print(f'{code} done')\n",
    "    return stock_data\n",
    "\n",
    "def get_data_for_period(stock_data, start_year=2009, end_year=2023):\n",
    "    period_data = {}\n",
    "    for code, data in stock_data.items():\n",
    "        start_date = pd.Timestamp(year=start_year, month=1, day=1)\n",
    "        end_date = pd.Timestamp(year=end_year, month=12, day=31)\n",
    "        period_data[code] = data[(data.index >= start_date) & (data.index <= end_date)]\n",
    "    return period_data\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "11bb1a13-03fe-4837-ae4b-84212a0f0241",
   "metadata": {},
   "source": [
    "### 3. 매수 및 매도 조건 체크 함수"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "8e7b1cfc-5298-4206-b460-d915f9112f0d",
   "metadata": {},
   "outputs": [],
   "source": [
    "def check_buy_sell_conditions(row, positions, capital, investment_per_split, num_splits, buy_threshold, buy_signals, sell_signals,code):\n",
    "    normalized = row['normalized_value']\n",
    "    # print(normalized)\n",
    "    current_pbr = row['PBR']\n",
    "    #avg_pbr = row['five_year_avg_pbr'] # 5년 평균 PBR\n",
    "    five_year_low = row['five_year_low']\n",
    "    current_order = len(positions) + 1  # 현재 매수할 포지션의 차수, 수정해야할듯 \n",
    "\n",
    "    # 변수 초기화\n",
    "    additional_buy_drop_rate = 0\n",
    "    sell_profit_rate = 0 \n",
    "    \n",
    "    # print(f'investment_per_split:{investment_per_split}')\n",
    "     # 1차 진입 조건: normalized 가격이 buy_threshold보다 낮고 아직 매수하지 않았을 때\n",
    "    if normalized < buy_threshold and len(positions) == 0:\n",
    "        if capital >= investment_per_split:\n",
    "            #차수별 수익률 계산 \n",
    "            additional_buy_drop_rate = calculate_additional_buy_drop_rate(row['종가'], five_year_low, num_splits)\n",
    "            # 매도 수익률 계산\n",
    "            sell_profit_rate = calculate_sell_profit_rate(additional_buy_drop_rate)\n",
    "            # print(buy_threshold,additional_buy_drop_rate,sell_profit_rate)\n",
    "            # 종가, 수량 , 차수\n",
    "            new_position = Position(row['종가'], int(investment_per_split / row['종가']), 1 ,sell_profit_rate, additional_buy_drop_rate)\n",
    "            positions.append(new_position)\n",
    "            capital -= row['종가']*int(investment_per_split / row['종가'])\n",
    "            # print(f'샀어1조건 현금은:{capital}', f'{row.name} 매입금액:{investment_per_split} 종가:{row[\"종가\"]} 차수별수익률:{additional_buy_drop_rate}')\n",
    "            # row.name은 현재 행의 인덱스 (날짜)를 반환. # 매수 시점 기록\n",
    "            buy_signals.append((row.name, row['종가']))\n",
    "    \n",
    "     # 추가 매수 조건: 이미 매수했고, 현재 가격이 이전 매수 가격보다 더 낮아졌을 때\n",
    "    elif positions and len(positions) < num_splits and capital >= investment_per_split:\n",
    "        last_position = positions[-1]  # 마지막 포지션(가장 최근 매수)\n",
    "        if row['종가'] <= positions[-1].buy_price * (1 - last_position.additional_buy_drop_rate):\n",
    "            new_position = Position(row['종가'], int(investment_per_split / row['종가']), len(positions) + 1,last_position.sell_profit_rate, last_position.additional_buy_drop_rate)\n",
    "            positions.append(new_position)\n",
    "            capital -= row['종가']*int(investment_per_split / row['종가'])\n",
    "            # print(f'샀어2조건 현금은:{capital}', f'{row.name} 매입금액:{investment_per_split} 종가:{row[\"종가\"]},차수별수익률:{last_position.additional_buy_drop_rate}')\n",
    "            buy_signals.append((row.name, row['종가']))\n",
    "\n",
    "   \n",
    "\n",
    "    # Sell condition for orders 2nd to 10th\n",
    "    for position in positions:\n",
    "        if row['종가'] >= position.buy_price * (1 + position.sell_profit_rate ) and position.order > 1:  # 2차이면서 매수가보다 일정비율이상되면\n",
    "            # print(f'매수단가: {position.buy_price} sell_profit_rate:{position.sell_profit_rate}') \n",
    "            capital += position.quantity * row['종가']\n",
    "            positions.remove(position)\n",
    "            sell_signals.append((row.name, row['종가'])) # 매도신호(날짜,단가) 저장\n",
    "            \n",
    "            # print(f'2~10차 팔았어 현금은: {capital} ,{row.name}, 종가:{row[\"종가\"]}') \n",
    "    \n",
    "    # 청산된 종목 확인을 위한 변수\n",
    "    liquidated = False\n",
    "    \n",
    "    # Final sell signal (liquidation) for 1st order 청산\n",
    "    for position in positions:\n",
    "        if  row['종가'] >= position.buy_price * (1 + position.sell_profit_rate ) and position.order == 1:  # 또는 이런 조건도 가능 current_pbr >= avg_pbr \n",
    "            capital += position.quantity * row['종가']\n",
    "            # print(f'청산 완료 현금은: {capital}') \n",
    "            positions.remove(position)\n",
    "            sell_signals.append((row.name, row['종가']))\n",
    "    # print(f'이날짜 현금은 결국 : {capital},{row.name}')\n",
    "            liquidated = True\n",
    "\n",
    "    # 청산된 경우 종목 코드 반환\n",
    "    if liquidated and not positions:\n",
    "        return positions, capital, code\n",
    "    else:\n",
    "        return positions, capital, None\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "73e7828e-1602-4443-b820-fe6708d6cd6e",
   "metadata": {},
   "source": [
    "### 4. 매수 및 매도 수익률 계산 함수"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "cc4d1b5a-75b6-4438-95ac-d42076979f1f",
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculate_additional_buy_drop_rate(last_buy_price, five_year_low, num_splits):\n",
    "    return 1 - ((five_year_low / last_buy_price) ** (1 / (num_splits - 1)))\n",
    "\n",
    "def calculate_sell_profit_rate(buy_profit_rate):\n",
    "    \"\"\"\n",
    "    매수 수익률을 기반으로 매도 수익률을 계산\n",
    "    :buy_profit_rate: 매수 기준 수익률\n",
    "    :return: 계산된 매도 수익률\n",
    "    \"\"\"\n",
    "    sell_profit_rate = (1 / (1 - buy_profit_rate)) - 1\n",
    "    return sell_profit_rate \n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d0c89af2-fecf-4980-9ff4-2d7df64f8a2f",
   "metadata": {},
   "source": [
    "### 5. 포트폴리오 가치 업데이트 함수"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "a8cd55ce-dbf5-4ab5-9bf3-9a2dfe9d3764",
   "metadata": {
    "jupyter": {
     "source_hidden": true
    }
   },
   "outputs": [],
   "source": [
    "def update_portfolio_values(positions, capital):\n",
    "    portfolio_value = capital + sum(position.quantity * position.buy_price for position in positions)\n",
    "    return portfolio_value"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "58676c20-d5b2-49d4-b7b1-a2a7cd038477",
   "metadata": {},
   "source": [
    "### 6. 최종 결과 계산 함수"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "e489e421-a837-49a5-85ee-1b7f0d2a16b5",
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculate_final_results(initial_capital, final_capital, total_days):\n",
    "    total_profit = final_capital  - initial_capital\n",
    "    return_on_investment = (total_profit / initial_capital) * 100\n",
    "    total_years = total_days / 365.25\n",
    "     # 예외 처리: 자본이 0 이하인 경우 CAGR 계산 방지\n",
    "    if final_capital <= 0:\n",
    "        cagr = -1  # 자본이 완전히 손실된 것으로 간주, CAGR을 -100%로 설정\n",
    "    else:\n",
    "        cagr = ((final_capital / initial_capital) ** (1 / total_years)) - 1\n",
    "\n",
    "    return total_profit, return_on_investment, cagr # 총수익률, ROI, 연환산수익률\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b073d591-42cc-4a88-928d-1b0e99833eb8",
   "metadata": {},
   "source": [
    "### 7. 종목 데이터 로드 및 기간 설정 함수"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "a05cbdde-3a84-4d90-8ffd-59b547bb5677",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_trading_dates_from_db(conn, start_date, end_date):\n",
    "    query = f\"SELECT DISTINCT date FROM stock_data WHERE date BETWEEN '{start_date}' AND '{end_date}' ORDER BY date\"\n",
    "    trading_dates = pd.read_sql(query, conn)['date'].tolist()\n",
    "    return trading_dates\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "52dd9e2e-8c1c-4aff-b094-de7dc96b4248",
   "metadata": {},
   "source": [
    "### 8. 포트폴리오 백테스팅 함수"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "0d54416c-5843-44c4-bc8e-4cb9db09adfc",
   "metadata": {},
   "outputs": [],
   "source": [
    "def portfolio_backtesting(stock_codes, initial_capital, num_splits, investment_ratio, buy_threshold, start_date, end_date,stock_data):\n",
    "    total_portfolio_value = initial_capital\n",
    "    capital = initial_capital  # capital을 초기 자본으로 초기화\n",
    "    positions_dict = {}  # 각 종목별 포지션 리스트를 위한 딕셔너리\n",
    "    buy_signals = []  # 매수 신호를 기록하는 리스트\n",
    "    sell_signals = []  # 매도 신호를 기록하는 리스트\n",
    "    portfolio_values_over_time = []\n",
    "    capital_over_time = []  # 자본 변화 추적을 위한 리스트 초기화\n",
    "\n",
    "    # 추가: 진입된 종목과 그들의 현재 최대 차수를 추적하기 위한 딕셔너리\n",
    "    entered_stocks = set()  # 진입된 종목을 추적하는 집합\n",
    "    current_orders_dict = {}  # 종목별 현재 차수를 추적하는 딕셔너리\n",
    "       \n",
    "    # print(all_trading_dates)\n",
    "    previous_month = None\n",
    "    \n",
    "    # 특정 기간 내의 모든 거래 날짜 가져오기\n",
    "    # DB 연결 설정\n",
    "    conn = pymysql.connect(**db_params)\n",
    "    all_trading_dates = get_trading_dates_from_db(conn, start_date, end_date)\n",
    "   \n",
    "    # 백테스팅 실행\n",
    "    for date_str  in all_trading_dates:\n",
    "        # print(date_str)\n",
    "        date = pd.to_datetime(date_str)# 날짜 문자열을 datetime 객체로 변환\n",
    "        \n",
    "        current_month = date.month\n",
    "        # 새로운 달의 시작일 경우, investment_per_split 업데이트\n",
    "        if current_month != previous_month:\n",
    "            investment_per_split = total_portfolio_value * investment_ratio // num_splits\n",
    "            # print(f'investment_per_split:{investment_per_split},total_portfolio_value : {total_portfolio_value}, investment_ratio : {investment_ratio},num_splits : {num_splits}')\n",
    "            previous_month = current_month\n",
    "        for code in stock_codes:\n",
    "            if date in stock_data[code].index:\n",
    "                row = stock_data[code].loc[date]\n",
    "\n",
    "                if len(entered_stocks) < 7 or code in entered_stocks: # 종목수 제한 \n",
    "                    positions = positions_dict[code]  # 현재 종목의 포지션 리스트\n",
    "                    # print(f'종목코드{code}')\n",
    "                    positions, capital ,liquidated_code = check_buy_sell_conditions(row, positions, capital, investment_per_split, num_splits, buy_threshold, buy_signals, sell_signals,code)\n",
    "                    positions_dict[code] = positions  # 업데이트된 포지션 리스트를 다시 딕셔너리에 저장\n",
    "                    # print('여긴가')\n",
    "                    # 추가: 진입된 종목과 그들의 현재 최대 차수 업데이트\n",
    "                    if positions:  # 해당 종목에 포지션이 있으면\n",
    "                        entered_stocks.add(code)\n",
    "                        current_order = max(position.order for position in positions)\n",
    "                        current_orders_dict[code] = current_order\n",
    "                    # 청산된 종목 제거\n",
    "                    if liquidated_code:\n",
    "                        entered_stocks.discard(liquidated_code)\n",
    "                        if liquidated_code in current_orders_dict:\n",
    "                            del current_orders_dict[liquidated_code]\n",
    "        # 포트폴리오 가치 업데이트\n",
    "        current_stock_value = 0\n",
    "        for code in stock_codes:\n",
    "            for position in positions_dict[code]:\n",
    "                current_stock_value += position.quantity * position.buy_price\n",
    "        total_portfolio_value = capital + current_stock_value\n",
    "        # print(f'현금:{capital},주식가격{current_stock_value},포트폴리오가격{total_portfolio_value}')\n",
    "        portfolio_values_over_time.append(total_portfolio_value)\n",
    "        capital_over_time.append(capital)  # 현재 자본 추가\n",
    "        # print(f\"1차로 진입된 종목 개수: {len(entered_stocks)}\")\n",
    "        # for code, order in current_orders_dict.items():\n",
    "            # print(f\"종목 코드 {code}의 현재 최대 차수: {order}\")\n",
    "     # 백테스팅 루프 종료 후\n",
    "    total_days = (all_trading_dates[-1] - all_trading_dates[0]).days\n",
    "    total_years = total_days / 365.25\n",
    "    final_portfolio_value = portfolio_values_over_time[-1]\n",
    "    cagr = ((final_portfolio_value / initial_capital) ** (1 / total_years)) - 1\n",
    "        \n",
    "    return positions_dict, total_portfolio_value, portfolio_values_over_time, capital_over_time, buy_signals, sell_signals, all_trading_dates, cagr\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b3b9c75d-3c17-42f2-81f5-9facab292456",
   "metadata": {},
   "source": [
    "### 9. 백테스팅 래퍼 및 평균 CAGR 계산 함수"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "99f4d998-c935-486c-9fc5-4a586b7694e3",
   "metadata": {},
   "outputs": [],
   "source": [
    "def backtesting_wrapper(params):\n",
    "    num_splits, buy_threshold, investment_ratio = params\n",
    "    try:\n",
    "        # print(f'Starting: num_splits={num_splits}, buy_threshold={buy_threshold}, investment_ratio={investment_ratio}')\n",
    "        _, _, _, _, _, _, _, cagr = portfolio_backtesting(stock_codes, initial_capital, num_splits, investment_ratio, buy_threshold, stock_data)\n",
    "        # print(f'Completed: num_splits={num_splits}, buy_threshold={buy_threshold}, investment_ratio={investment_ratio}, CAGR={cagr}')\n",
    "        return num_splits, buy_threshold, investment_ratio, cagr\n",
    "    except Exception as e:\n",
    "        print(f'Error in backtesting: {e}')\n",
    "        return num_splits, buy_threshold, investment_ratio, None  # 오류가 발생한 경우 CAGR을 None으로 설정\n",
    " \n",
    "def check_if_already_calculated(num_splits, buy_threshold, investment_ratio):\n",
    "    if os.path.exists(results_file):\n",
    "        existing_results = pd.read_csv(results_file)\n",
    "        return any((existing_results['num_splits'] == num_splits) & \n",
    "                   (existing_results['buy_threshold'] == buy_threshold) &\n",
    "                   (existing_results['investment_ratio'] == investment_ratio))\n",
    "    return False   \n",
    "\n",
    "def run_backtesting_for_period(stock_codes, initial_capital, num_splits, investment_ratio, buy_threshold, start_year, end_year, loaded_stock_data):\n",
    "    # 주어진 기간에 대한 데이터 로드\n",
    "    period_stock_data = get_data_for_period(loaded_stock_data, start_year, end_year)\n",
    "    \n",
    "    # 백테스팅 수행\n",
    "    _, total_portfolio_value, _, _, _, _, _, cagr = portfolio_backtesting(\n",
    "        stock_codes, initial_capital, num_splits, investment_ratio, buy_threshold, loaded_stock_data)\n",
    "    \n",
    "    return total_portfolio_value, cagr\n",
    "\n",
    "def calculate_average_results(backtesting_results):\n",
    "    total_values = [result[0] for result in backtesting_results]\n",
    "    cagr_values = [result[1] for result in backtesting_results]\n",
    "\n",
    "    average_total_value = sum(total_values) / len(total_values)\n",
    "    average_cagr = sum(cagr_values) / len(cagr_values)\n",
    "\n",
    "    return average_total_value, average_cagr\n",
    "\n",
    "# 시간 기간에 따른 평균 CAGR을 계산하는 래퍼 함수\n",
    "def average_cagr_wrapper(params):\n",
    "    num_splits, buy_threshold, investment_ratio = params\n",
    "    period_results = []\n",
    "    for start_year, end_year in time_periods:\n",
    "        try:\n",
    "            total_value, cagr = run_backtesting_for_period(\n",
    "                stock_codes, initial_capital, num_splits, investment_ratio, buy_threshold, start_year, end_year,stock_data)\n",
    "            period_results.append((total_value, cagr))\n",
    "            print(f'기간 하나 완료{params}')\n",
    "        except Exception as e:\n",
    "            print(f'Error in backtesting for period {start_year}-{end_year}: {e}')\n",
    "            period_results.append((0, None))  # 오류가 발생한 경우 결과를 (0, None)으로 설정\n",
    "\n",
    "    average_results = calculate_average_results(period_results)\n",
    "    return num_splits, buy_threshold, investment_ratio, average_results[0], average_results[1]\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd795900-32fe-48a9-b239-143e3449726a",
   "metadata": {},
   "source": [
    "### 10. 메인 실행 코드"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 105,
   "id": "1b5bd0be-e8a6-4c24-b46e-10641daab919",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Converted date: 2002-05-02\n",
      "조건을 만족하는 종목 코드: ['000490', '000970', '001060', '001270', '001500', '001750', '002000', '002310', '002710', '002810', '002960', '003070', '003080', '003650', '003720', '004200', '004270', '004310', '004380', '004450', '004620', '005190', '005320', '005820', '005980', '007120', '007540', '007980', '008020', '008560', '008600', '009680', '010660', '011280', '011420', '012320', '012600', '012610', '014350', '014590', '015350', '015360', '015590', '016450', '016590', '016610', '017390', '019300', '021050', '021820', '023450', '024900', '025850', '026870', '026890', '030720', '036460', '036580']\n"
     ]
    }
   ],
   "source": [
    "# 설정 파일 읽기\n",
    "config = configparser.ConfigParser()\n",
    "config.read('config.ini')\n",
    "\n",
    "# 데이터베이스 연결 정보 설정\n",
    "db_params = {\n",
    "    'host': config['mysql']['host'],\n",
    "    'user': config['mysql']['user'],\n",
    "    'password': config['mysql']['password'],\n",
    "    'database': config['mysql']['database'],\n",
    "}\n",
    "\n",
    "# 백테스팅 파라미터\n",
    "initial_capital = 100000000  # 초기 자본\n",
    "num_splits_options = [10] # 15,20,25,30\n",
    "buy_threshold_options = [30 ] # 35, 40, 45, 50, 55, 60\n",
    "investment_ratio_options = [0.15] # 0.2 , 0.25, 0.3, 0.35, 0.4, 0.45, 0.5\n",
    "\n",
    "time_periods = [(2009, 2014)] #  (2011, 2016), (2013, 2018), (2015, 2020), (2017, 2022), (2018, 2023), (2009, 2016), (2016, 2023)\n",
    "\n",
    "\n",
    "start_date = '2009-01-01'\n",
    "end_date = '2014-12-31'\n",
    "\n",
    "# 동적으로 조건을 만족하는 종목 리스트 가져오기\n",
    "date = '2002-5-02'  # 조건을 만족하는 종목을 가져올 기준 날짜 2002-05-02부터 종목들이 등장\n",
    "# pbr 조건은 2002년 4월 23일부터 생성됨 \n",
    "# div 조건은 2000년 1월 4일부터 \n",
    "# per 조건은 2000년 1월 4일부터 \n",
    "# cf ) market_cap은 1995년\n",
    "per_threshold = 10\n",
    "pbr_threshold = 1\n",
    "div_threshold = 3.5\n",
    "normalized_value_threshold = 30\n",
    "\n",
    "# 조건을 만족하는 종목 코드 가져오기\n",
    "stock_codes = get_stock_codes(date, per_threshold, pbr_threshold, div_threshold, normalized_value_threshold, db_params)\n",
    "print(f\"조건을 만족하는 종목 코드: {stock_codes}\")\n",
    "\n",
    "\n",
    "# # 모든 종목 데이터 로드\n",
    "# stock_data = load_all_stock_data(stock_codes, start_date, end_date, db_params)\n",
    "\n",
    "# # 백테스팅 수행\n",
    "# positions_dict, total_portfolio_value, portfolio_values_over_time, capital_over_time, buy_signals, sell_signals, all_trading_dates, cagr = portfolio_backtesting(\n",
    "#     stock_codes, initial_capital, num_splits, investment_ratio, buy_threshold, start_date, end_date, stock_data\n",
    "# )\n",
    "\n",
    "# print(f\"최종 포트폴리오 가치: {total_portfolio_value}\")\n",
    "# print(f\"CAGR: {cagr}\")\n",
    "\n",
    "\n",
    "# combinations = [(n, b, i) for n in num_splits_options for b in buy_threshold_options for i in investment_ratio_options]\n",
    "# # 결과를 DataFrame으로 변환하여 출력\n",
    "# results_df = pd.DataFrame(all_results, columns=[\"num_splits\", \"buy_threshold\", \"investment_ratio\", \"Average_Total_Value\", \"Average_CAGR\"])\n",
    "# print(results_df.sort_values(by=\"Average_CAGR\", ascending=False))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4ba26193",
   "metadata": {},
   "source": [
    "### 병렬 백테스팅 실행 및 결과 저장\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "422d3c8a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Error in backtesting for period 2009-2014: name 'stock_codes' is not defined\n",
      "Error in backtesting for period 2009-2014: name 'stock_codes' is not defined\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "  0%|          | 0/2 [00:00<?, ?it/s]\n"
     ]
    },
    {
     "ename": "TypeError",
     "evalue": "unsupported operand type(s) for +: 'int' and 'NoneType'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[25], line 6\u001b[0m\n\u001b[0;32m      4\u001b[0m     results \u001b[38;5;241m=\u001b[39m []\n\u001b[0;32m      5\u001b[0m     \u001b[38;5;28;01mfor\u001b[39;00m future \u001b[38;5;129;01min\u001b[39;00m tqdm(concurrent\u001b[38;5;241m.\u001b[39mfutures\u001b[38;5;241m.\u001b[39mas_completed(futures), total\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mlen\u001b[39m(combinations)):\n\u001b[1;32m----> 6\u001b[0m         result \u001b[38;5;241m=\u001b[39m \u001b[43mfuture\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mresult\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m      7\u001b[0m         results\u001b[38;5;241m.\u001b[39mappend(result)\n\u001b[0;32m      9\u001b[0m \u001b[38;5;66;03m# 결과 DataFrame 생성 및 저장\u001b[39;00m\n",
      "File \u001b[1;32mc:\\Program Files\\Python312\\Lib\\concurrent\\futures\\_base.py:449\u001b[0m, in \u001b[0;36mFuture.result\u001b[1;34m(self, timeout)\u001b[0m\n\u001b[0;32m    447\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m CancelledError()\n\u001b[0;32m    448\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_state \u001b[38;5;241m==\u001b[39m FINISHED:\n\u001b[1;32m--> 449\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43m__get_result\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m    451\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_condition\u001b[38;5;241m.\u001b[39mwait(timeout)\n\u001b[0;32m    453\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_state \u001b[38;5;129;01min\u001b[39;00m [CANCELLED, CANCELLED_AND_NOTIFIED]:\n",
      "File \u001b[1;32mc:\\Program Files\\Python312\\Lib\\concurrent\\futures\\_base.py:401\u001b[0m, in \u001b[0;36mFuture.__get_result\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    399\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_exception:\n\u001b[0;32m    400\u001b[0m     \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[1;32m--> 401\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_exception\n\u001b[0;32m    402\u001b[0m     \u001b[38;5;28;01mfinally\u001b[39;00m:\n\u001b[0;32m    403\u001b[0m         \u001b[38;5;66;03m# Break a reference cycle with the exception in self._exception\u001b[39;00m\n\u001b[0;32m    404\u001b[0m         \u001b[38;5;28mself\u001b[39m \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m\n",
      "File \u001b[1;32mc:\\Program Files\\Python312\\Lib\\concurrent\\futures\\thread.py:58\u001b[0m, in \u001b[0;36m_WorkItem.run\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m     55\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m\n\u001b[0;32m     57\u001b[0m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[1;32m---> 58\u001b[0m     result \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mfn\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m     59\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m \u001b[38;5;167;01mBaseException\u001b[39;00m \u001b[38;5;28;01mas\u001b[39;00m exc:\n\u001b[0;32m     60\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mfuture\u001b[38;5;241m.\u001b[39mset_exception(exc)\n",
      "Cell \u001b[1;32mIn[23], line 53\u001b[0m, in \u001b[0;36maverage_cagr_wrapper\u001b[1;34m(params)\u001b[0m\n\u001b[0;32m     50\u001b[0m         \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mError in backtesting for period \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mstart_year\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m-\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mend_year\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m: \u001b[39m\u001b[38;5;132;01m{\u001b[39;00me\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m'\u001b[39m)\n\u001b[0;32m     51\u001b[0m         period_results\u001b[38;5;241m.\u001b[39mappend((\u001b[38;5;241m0\u001b[39m, \u001b[38;5;28;01mNone\u001b[39;00m))  \u001b[38;5;66;03m# 오류가 발생한 경우 결과를 (0, None)으로 설정\u001b[39;00m\n\u001b[1;32m---> 53\u001b[0m average_results \u001b[38;5;241m=\u001b[39m \u001b[43mcalculate_average_results\u001b[49m\u001b[43m(\u001b[49m\u001b[43mperiod_results\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m     54\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m num_splits, buy_threshold, investment_ratio, average_results[\u001b[38;5;241m0\u001b[39m], average_results[\u001b[38;5;241m1\u001b[39m]\n",
      "Cell \u001b[1;32mIn[23], line 35\u001b[0m, in \u001b[0;36mcalculate_average_results\u001b[1;34m(backtesting_results)\u001b[0m\n\u001b[0;32m     32\u001b[0m cagr_values \u001b[38;5;241m=\u001b[39m [result[\u001b[38;5;241m1\u001b[39m] \u001b[38;5;28;01mfor\u001b[39;00m result \u001b[38;5;129;01min\u001b[39;00m backtesting_results]\n\u001b[0;32m     34\u001b[0m average_total_value \u001b[38;5;241m=\u001b[39m \u001b[38;5;28msum\u001b[39m(total_values) \u001b[38;5;241m/\u001b[39m \u001b[38;5;28mlen\u001b[39m(total_values)\n\u001b[1;32m---> 35\u001b[0m average_cagr \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;43msum\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mcagr_values\u001b[49m\u001b[43m)\u001b[49m \u001b[38;5;241m/\u001b[39m \u001b[38;5;28mlen\u001b[39m(cagr_values)\n\u001b[0;32m     37\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m average_total_value, average_cagr\n",
      "\u001b[1;31mTypeError\u001b[0m: unsupported operand type(s) for +: 'int' and 'NoneType'"
     ]
    }
   ],
   "source": [
    "\n",
    "with concurrent.futures.ThreadPoolExecutor(max_workers=224) as executor:\n",
    "    futures = [executor.submit(average_cagr_wrapper, param) for param in combinations]\n",
    "    # results = [future.result() for future in concurrent.futures.as_completed(futures)]\n",
    "    results = []\n",
    "    for future in tqdm(concurrent.futures.as_completed(futures), total=len(combinations)):\n",
    "        result = future.result()\n",
    "        results.append(result)\n",
    "\n",
    "# 결과 DataFrame 생성 및 저장\n",
    "results_df = pd.DataFrame(results, columns=[\"num_splits\", \"buy_threshold\", \"investment_ratio\", \"Average_Total_Value\", \"Average_CAGR\"])\n",
    "results_df.to_csv('average_backtesting_results_7_10split_2.csv', index=False)\n",
    "\n",
    "# 결과 출력\n",
    "# print(results_df.sort_values(by=\"Average_CAGR\", ascending=False))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
